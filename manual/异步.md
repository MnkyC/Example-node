# 简介
JavaScript是单线程模型，只在一个线程上运行，同时只能执行一个任务，其他任务需要排队

JavaScript引擎是多线程模型，单个脚本只能在一个线程(主线程)上运行，其他线程都在后台配置

很多时候CPU是闲着的，因为IO操作很慢，不得不等待结果，完了再往下执行，这时CPU完全可以挂起等待IO操作的任务，先运行后面排队的任务，等到IO操作返回结果了再回来把挂起的任务继续执行下去，所以，JavaScript内部采用了**“事件循环”机制**
# 同步和异步任务
同步任务，没被引擎挂起，在主线程上排队执行的任务，前一个任务执行完毕后才能执行后一个任务

异步任务，不进入主线程而进入任务队列的任务，只有引擎认为某个任务可以执行了才会进入主线程执行，异步任务后面的任务不用等待，可以直接执行
# 任务队列和事件循环
JavaScript在运行时，除了正在运行的主线程，还有一个任务队列(实际上根据异步任务的类型，存在多个任务队列)
## 执行流程
1. 主线程会执行所有同步任务
2. 同步任务执行完后会查看任务队列中的异步任务
3. 有异步任务满足条件，会重新进入主线程执行，这时它就是同步任务
4. 执行完后，下一个异步任务再根据条件进入主线程执行
5. 重复3，4步骤，直到任务队列清空

**异步任务一般是用回调函数处理**，当其重新进入主线程时就会执行对应的回调函数，没有回调函数的异步任务就不会进入任务队列，即不会重新进入主线程

JavaScript引擎通过事件循环，不停地，只要同步任务执行完了，就对任务队列进行检查，检查其是否可以进入主线程执行了
# 异步操作的模式
## 回调函数
优点：简单，易理解，易实现

缺点：不方便阅读和维护，高度耦合，且只能指定一个回调函数
## 事件监听
取决于事件是否发生，和代码顺序无关

优点：易理解，可绑定多个事件，每个事件又能指定多个回调函数，去耦合，利于模块化

缺点：整个程序都会是事件驱动型，运行流程不清晰
## 发布和订阅
有一个信号中心，任务完成后，就向其发送信号，其他任务向其订阅信号，这样就知道什么时候开始执行

方式和事件监听类似，但是优于事件监听，可以通过消息中心，了解信号量，订阅者等信息，监控程序运行
# 异步操作的流程控制
## 串行执行
一个流程控制函数，里面用数组的push和shift来控制任务
## 并行执行
一个流程控制函数，里面用forEach遍历数组，同时发起几个任务
## 串行和并行结合
加一个门槛，每次最多只能并行执行n个异步任务，避免资源过分占用
# 定时器
定时执行代码
# Promise
**JavaScript异步操作的解决方案，为异步操作提供统一接口**，代理作用，充当异步操作和回调函数之间的中介，使异步操作具备同步操作的接口

Promise是一个对象，也是一个构造函数，其设计思想是，所有异步任务都返回一个Promise实例，该实例有一个**then**方法，用于指定下一步的回调函数



# bluebird, 更强大的Promise