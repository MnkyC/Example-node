## 算术运算
### +, -, *, /, **(指数), %, ++x, x++, --x, x--, -x(负数值)

**和赋值运算符结合后的变体，+=, -=, \*=, /=, \*\*=, %=**
### 加法要特别注意
允许非数值的相加

	对于布尔值和数值相加会先将布尔转为数值
	true + true // 2
	1 + true // 2
	对于字符串，加法运算变成了连接运算，和非字符串相加会先将非字符串转为字符串
	'a' + 'bc' // abc
	1 + 'a' // 1a
**加法运算在运行时决定相加还是连接，运算子的不同导致了不同的行为，这就是“重载”，只有加法会发生重载，其他运算符不会，他们都是先转为数值再进行数学运算**

注意字符串的位置，从左到右的运算次序会导致不同的结果

	'3' + 4 + 5 // 345
	3 + 4 + '5' // 75

### 余数运算符要注意，结果的正负号有第一个运算子决定

	-1 % 2 // -1
	1 % -2 // 1
所以，为了得到负数的正确余数要先使用绝对值

### 自增和自减是一元运算符，只需要一个运算子，也是先转为数值
运算符在前先进行运算再返回操作后的值；运算符在后先返回操作前的值再进行运算

### 指数运算，底数在前指数在后，右结合，先进行最右边的运算

## 比较运算
### ==, !=, ===, !==, >, >=, <, <=
分为相等比较和不等比较，两者规则不同

不等比较，先看是否都是字符串，是就按照字典顺序(JS引擎内部首先比较首字符的Unicode码(字母和汉字都有)，相等再往后比较)比较大小；否则，都转为数值比较大小

**任何值和NaN比较，不管什么比较运算符，返回都是false**

**推荐使用===, !==，同时比较值和类型，对于复合类型的值则比较是否引用同一个内存地址**


undefined和null都和自身严格相等，所以，对于只声明没赋值的变量是严格相等的

严格不相等!==，是先求严格相等的结果，再取反 !(a === b)
## 布尔运算
### !, &&, ||, ?:

**! 布尔取反**，该运算符总会得到一个boolean值，所以可以用来将非boolean的转为boolean类型

**且运算 && 满足短路原则(跳过第二个运算子的机制)**

	第一个运算子为true，则返回第二个运算子的值(注意，不是布尔值)
	第一个运算子为false，则直接返回第一个运算子的值，且不对后面求值
	't' && '' // ""
	't' && 'f' // "f"
	't' && (1 + 2) // 3
	'' && 'f' // ""
	'' && '' // ""
	let x = 1;
	(1 - 1) && (x += 1) // 0
	x // 1
	短路原则可以用于简化if结构，但不容易排错，谨慎使用
		if (b) { func(); } 等价于 b && func();
**或运算 || 也满足短路原则**

	第一个运算子为true，则返回第一个运算子的值，且不对后面求值
	第一个运算子为false，则返回第二个运算子的值
	't' || '' // "t"
	't' || 'f // "t"
	'' || 'f' // "f"
	'' || '' // ""
	let x = 1;
	true || (x = 2) //true
	x // 1
**或运算还经常用于为变量设置一个默认值**，用法类似于Lua的or

	text = text || '';
	func(text || '')
**三目运算，JavaScript唯一一个需要三个运算子的运算符**

	对于只有两种情况的可以用三目
		赋值，var n = foo ? 1 : 2;
		函数，foo ? func1() : func2();
		
## 二进制运算
### &, |, ~, ^, <<, >>, >>>

**和赋值运算符结合后的变体，&=, |=, ^=, <<=, >>=, >>>=**

直接操作每一个比特位，底层的运算，速度很快

只对整数作用，不是整数就自动转为整数(直接舍去小数部分，不进行四舍五入)，虽然数值都是64位浮点数的形式存储，但做位运算时是以32位带符号的整数进行运算的，返回值也是一个32位带符号的整数

对于其他类型的值，都是先用Number函数转为数值再运算

	function toInt32(x) { return x | 0; } // 将任意数值转为32位整数
	不适用于超过32位的整数
### 二进制否运算符~，一个数和自身的取反值相加，等于-1

	~ -3 // 也就是-1减去-3，等于2
	整数连续两次否运算后得到自身
	~~3 // 3
	浮点数会先舍去小数部分，两次连续否运算后得到整数部分
	~~2.9 // 2
**二进制否运算取整是所有方法中最快的**

### 异或运算，相同时返回0，不同时返回1，且有个特殊运用，连续对两个值进行三次异或运算能交换它们的值，并且不需要引入临时变量

**异或运算是交换两个变量的值的最快方法**

### 左移运算，就是根据移动位数，尾部补0，即乘以2的指定次方

	左移0位，相当于将该数值转为32位整数，等价于取整
	13.5 << 0 // 13
	-13.5 << 0 // -13
### 右移运算，就是根据移动位数，正数头部补0，负数头部补1，即除以2的指定次方

	可以模拟2的整除运算
	5 >> 1 // 2
	4 >> 1 // 2
	-4 >> 1 // -2
### 头部补零的右移运算符>>>，与>>的唯一区别就是，头部一律补零，不考虑符号位，总是得到正数
## 其他
### void运算符
指定一个表达式，不返回任何值，其实是返回undefined
